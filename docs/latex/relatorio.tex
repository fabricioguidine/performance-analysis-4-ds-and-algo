% Technical Report - Performance Analysis for Data Structures and Algorithms
% Analysis of Sorting Algorithms, Hash Tables and Balanced Trees
% Dataset: Book Depository
% Template: UFJF Monografia Modelo

\NeedsTeXFormat{LaTeX2e}
\documentclass[a4paper,12pt]{monografia}

% Packages
\usepackage[portuguese, colorinlistoftodos, textsize=tiny]{todonotes}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage[mathcal]{eucal}
\usepackage{latexsym}
\usepackage[english]{babel}  
\usepackage[utf8]{inputenc}
\usepackage{setspace}
\usepackage{bm}
\usepackage[portuguese,algoruled,longend, linesnumbered]{algorithm2e}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{subcaption}
\usepackage{float}
\usepackage[labelsep=period]{caption}
\usepackage{hyperref}
\usepackage{url}
\usepackage{array}
\usepackage{tabularx}
\usepackage{caption}

% Table caption configuration - centered and above table
\captionsetup[table]{justification=centering, position=above, singlelinecheck=false}

% Hyperref configuration
\hypersetup{
    colorlinks,
    debug=false,
    linkcolor=black,
    citecolor=black,
    urlcolor=black,
    bookmarksopen=true,
    pdftitle={Performance Analysis for Data Structures and Algorithms - Book Depository Dataset},
    pdfauthor={Débora Duarte, Fabrício Guidine, Walkíria Garcia},
    pdfsubject={Algorithms and Data Structures Analysis},
    pdfkeywords={algorithms, data structures, sorting, hash tables, balanced trees},
    pdflang={en-US},
}

% Bibliography
\usepackage[alf,bibjustif]{abntex2cite}

% Listings configuration for code
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\lstset{style=mystyle}

% New counter for comments
\newcounter{todocounter}
\newcommand{\comment}[2][]
{\stepcounter{todocounter}\todo[caption={\thetodocounter: #2}, #1] 
{\begin{spacing}{1}\thetodocounter: #2\end{spacing}}}

\reversemarginpar
\setlength{\marginparwidth}{2.5cm}
\lstloadlanguages{Java}

% Theorem environments
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{axiom}{Axiom}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{example}{Example}[section]

\theoremstyle{remark}
\newtheorem{remark}{Remark}[section]

% Mathematical notations
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\I}{\mathbb{I}}
\newcommand{\id}{\mathbf{1}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\V}{{\cal V}}

% Define fonte command for table sources
\providecommand{\fonte}[1]{%
    \vspace{-0.3cm}
    \begin{flushleft}
    \footnotesize\textit{Source: #1}
    \end{flushleft}%
}

% Index
\makeindex

% Include hyphenation
\include{hifenizacao}

\begin{document}
% Title information
\title{Performance Analysis for Data Structures and Algorithms\\
Using the Book Depository Dataset}

\author{Débora Duarte\\Fabrício Guidine\\Walkíria Garcia}

\local{Juiz de Fora}

\date{November 25, 2020}

\institution{Universidade Federal de Juiz de Fora}

\course{Department of Computer Science\\
DCC012 - Data Structures II}

% Include pretext (title page only)
\include{pretexto}

% Main Content - Single column
\singlespacing

\chapter{Introduction}

This report presents a comprehensive analysis of fundamental data structures and algorithms in Computer Science, using the Book Depository dataset as the data source for the conducted experiments.

\section{Context}

The project was developed as part of the requirements for the DCC012 - Data Structures II course, at the Department of Computer Science of the Universidade Federal de Juiz de Fora, in the 2020.1 semester.

\section{Objectives}

The main objectives of this work include:

\begin{itemize}
    \item Implement and analyze sorting algorithms (QuickSort and HeapSort)
    \item Implement hash tables for author frequency analysis
    \item Evaluate the performance of balanced data structures (Red-Black Tree and B+ Tree)
    \item Compare performance metrics between different structures and algorithms
    \item Generate empirical results through controlled experiments
\end{itemize}

\section{Report Organization}

This report is organized as follows:

\begin{itemize}
    \item \textbf{Chapter 2}: Literature review on the studied structures and algorithms
    \item \textbf{Chapter 3}: Methodology and description of experiments
    \item \textbf{Chapter 4}: Sorting algorithms analysis
    \item \textbf{Chapter 5}: Hash tables analysis
    \item \textbf{Chapter 6}: Balanced data structures analysis
    \item \textbf{Chapter 7}: Results and discussion
    \item \textbf{Chapter 8}: Conclusions and future work
\end{itemize}

\chapter{Literature Review}

\section{Sorting Algorithms}

\subsection{QuickSort}

QuickSort is an efficient sorting algorithm that uses the divide-and-conquer strategy \cite{cormen2009}. It works by selecting a pivot element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. QuickSort has an average time complexity of $O(n \log n)$, but its worst-case complexity is $O(n^2)$.

\subsection{HeapSort}

HeapSort uses the heap property to sort elements \cite{knuth1998}. It first builds a max-heap from the input array, then repeatedly extracts the maximum element from the heap and places it at the end of the sorted array. HeapSort has a guaranteed time complexity of $O(n \log n)$ for all cases, making it more predictable than QuickSort, though typically slower in practice.

\section{Hash Tables}

Hash tables are data structures that allow fast access to elements through hash functions \cite{cormen2009}. They provide average-case constant time complexity $O(1)$ for insertion, deletion, and search operations. This project implements hash tables using open addressing with double hashing to resolve collisions.

\section{Balanced Data Structures}

\subsection{Red-Black Tree}

Red-Black trees are self-balancing binary search trees where each node has an extra bit to store its color (red or black) \cite{cormen2009}. These trees maintain balance by ensuring that no path from root to leaf is more than twice as long as any other path, resulting in guaranteed $O(\log n)$ time complexity for insertion, deletion, and search operations.

\subsection{B+ Tree}

B+ trees are data structures optimized for disk storage and are commonly used in database systems \cite{knuth1998}. They are similar to B-trees but store all data in leaf nodes, with internal nodes containing only keys for navigation. B+ trees maintain a balanced structure with a minimum degree $d$, where each internal node has at least $d$ and at most $2d$ children. This structure provides efficient sequential access and is particularly suitable for large datasets.

\chapter{Methodology}

\section{Dataset}

The Book Depository dataset was obtained from Kaggle \cite{kaggle_dataset} and contains information about books, including:

\begin{itemize}
    \item Author data and their works
    \item Book information (title, ISBN, categories)
    \item Bestseller rankings
    \item Reviews and ratings
\end{itemize}

\section{Performance Metrics}

For each algorithm and data structure, the following metrics were measured:

\begin{itemize}
    \item \textbf{Number of comparisons}: Quantity of comparisons between elements
    \item \textbf{Number of swaps/copies}: Quantity of data movement operations
    \item \textbf{Execution time}: Total processing time in milliseconds
\end{itemize}

\section{Execution Environment}

The experiments were executed in:
\begin{itemize}
    \item Language: Java
    \item Environment: JVM (Java Virtual Machine)
    \item Operating system: Windows/Linux
    \item Metrics: Machine time (not wall-clock time)
\end{itemize}

\section{Testing Methodology}

To ensure the correctness and reliability of all implemented algorithms and data structures, a comprehensive test suite was developed using modern Java testing frameworks. The testing framework validates all components of the project through unit tests, integration tests, and performance benchmarks.

\subsection{Testing Frameworks}

The test suite utilizes multiple testing frameworks to ensure comprehensive coverage:

\begin{itemize}
    \item \textbf{JUnit 5 (Jupiter)}: Primary unit testing framework for modern Java testing
    \item \textbf{JUnit 4}: Backward compatibility support for legacy tests
    \item \textbf{Mockito}: Mocking framework for isolating components under test
    \item \textbf{AssertJ}: Fluent assertions library for readable test assertions
    \item \textbf{JMH (Java Microbenchmark Harness)}: Framework for precise microbenchmarking and performance measurement
    \item \textbf{Hamcrest}: Matcher library for expressive assertions
\end{itemize}

\subsection{Test Coverage}

The test suite includes comprehensive coverage for all algorithm implementations:

\subsubsection{Sorting Algorithms Tests}

Unit tests for sorting algorithms are implemented in:
\begin{itemize}
    \item \texttt{QuickSortTest.java}: Comprehensive unit tests for QuickSort algorithm
    \item \texttt{HeapSortTest.java}: Comprehensive unit tests for HeapSort algorithm
\end{itemize}

These tests validate:
\begin{itemize}
    \item \textbf{Edge Cases}: Empty arrays, null arrays, single element arrays
    \item \textbf{Input Variations}: Already sorted arrays, reverse sorted arrays, random order arrays
    \item \textbf{Special Cases}: Arrays with duplicate ranks, arrays with zero ranks
    \item \textbf{Correctness}: Verification that arrays are properly sorted after algorithm execution
    \item \textbf{Performance Metrics}: Tracking of comparisons, swaps, and execution time
    \item \textbf{Scalability}: Testing with various input sizes (10, 100, 1000, 10000, 50000 elements)
    \item \textbf{Parameterized Tests}: Testing multiple input sizes systematically using JUnit 5 parameterized tests
\end{itemize}

\subsubsection{Performance Tests}

Performance testing is implemented through:
\begin{itemize}
    \item \texttt{PerformanceTest.java}: Performance benchmarks for sorting algorithms
    \item \texttt{SortingBenchmark.java}: JMH microbenchmarks for precise performance measurement
\end{itemize}

Performance tests evaluate:
\begin{itemize}
    \item Execution time across different input sizes (100, 1000, 10000, 100000 elements)
    \item Algorithm comparison (QuickSort vs HeapSort) with identical input data
    \item Performance with different input distributions (sorted, reverse sorted, random)
    \item Memory efficiency and resource usage
    \item Consistent performance characteristics across multiple runs
\end{itemize}

\subsubsection{Integration Tests}

Integration tests verify end-to-end functionality:
\begin{itemize}
    \item \texttt{SortingExperimentIntegrationTest.java}: Validates complete experiment execution workflow
    \item Tests multiple algorithm runs with consistency checks
    \item Verifies result reproducibility across executions
\end{itemize}

\subsubsection{Test Utilities}

Supporting test utilities are provided in:
\begin{itemize}
    \item \texttt{TestUtils.java}: Utility methods for generating test data (sorted, reverse sorted, random arrays)
    \item Helper methods for creating test records with specific ranks
    \item Methods for verifying array sorting correctness
    \item Data cloning utilities for fair algorithm comparisons
\end{itemize}

\subsection{Test Execution}

All tests are executed using Maven through the Maven Surefire plugin:

\begin{itemize}
    \item \texttt{mvn test}: Executes all unit tests
    \item \texttt{mvn test -Dtest=QuickSortTest}: Execute specific test class
    \item \texttt{mvn test -Dtest=SortingBenchmark}: Execute JMH benchmarks
\end{itemize}

The test suite validates:
\begin{itemize}
    \item Correctness of all algorithm implementations
    \item Proper behavior of data structures under various conditions
    \item Edge cases including null inputs, empty collections, and boundary conditions
    \item Performance tracking mechanisms (comparisons, swaps, execution time)
    \item Data integrity and consistency
    \item Scalability and performance characteristics
\end{itemize}

The comprehensive test suite ensures that all implementations maintain correctness across different scenarios and edge cases, providing confidence in the experimental results presented in this report.

\chapter{Sorting Algorithms Analysis}

\section{Experiment Methodology}

The sorting experiments were conducted with different input sizes. Each algorithm was tested with datasets of varying sizes to observe how performance scales with input size.

\section{Results}

The results from the sorting experiments are available in the \texttt{output/} folder. The analysis was performed considering different input sizes to compare algorithm performance.

\subsection{QuickSort}

The QuickSort results show:

\begin{itemize}
    \item Number of comparisons performed
    \item Number of swaps/copies of elements
    \item Execution time in milliseconds
\end{itemize}

% Fixed table for QuickSort results
\begin{table}[H]
\centering
\caption{QuickSort results for different input sizes}
\label{tab:quicksort-results}
\begin{tabular}{c c c c}
    \toprule
    \textbf{Size (n)} & \textbf{Comparisons} & \textbf{Swaps} & \textbf{Time (ms)} \\
    \midrule
    1,000 & -- & -- & -- \\
    5,000 & -- & -- & -- \\
    10,000 & -- & -- & -- \\
    50,000 & -- & -- & -- \\
    100,000 & -- & -- & -- \\
    \bottomrule
\end{tabular}
\fonte{Results from conducted experiments.}
\end{table}

\subsection{HeapSort}

The HeapSort results show:

\begin{itemize}
    \item Number of comparisons performed
    \item Number of swaps/copies of elements
    \item Execution time in milliseconds
\end{itemize}

% Fixed table for HeapSort results
\begin{table}[H]
\centering
\caption{HeapSort results for different input sizes}
\label{tab:heapsort-results}
\begin{tabular}{c c c c}
    \toprule
    \textbf{Size (n)} & \textbf{Comparisons} & \textbf{Swaps} & \textbf{Time (ms)} \\
    \midrule
    1,000 & -- & -- & -- \\
    5,000 & -- & -- & -- \\
    10,000 & -- & -- & -- \\
    50,000 & -- & -- & -- \\
    100,000 & -- & -- & -- \\
    \bottomrule
\end{tabular}
\fonte{Results from conducted experiments.}
\end{table}

\section{Comparative Analysis}

To compare the sorting algorithms, a comparative analysis was performed considering performance metrics. Table \ref{tab:sorting-comparison} presents a comparative summary between QuickSort and HeapSort.

\begin{table}[H]
\centering
\caption{Comparative analysis between QuickSort and HeapSort}
\label{tab:sorting-comparison}
\begin{tabular}{l c c c}
    \toprule
    \textbf{Metric} & \textbf{QuickSort} & \textbf{HeapSort} & \textbf{Observations} \\
    \midrule
    Complexity (worst case) & $O(n^2)$ & $O(n \log n)$ & HeapSort guarantees $O(n \log n)$ \\
    Complexity (average case) & $O(n \log n)$ & $O(n \log n)$ & Both have same average complexity \\
    Complexity (best case) & $O(n \log n)$ & $O(n \log n)$ & Both have same best case complexity \\
    Stability & Unstable & Unstable & -- \\
    Memory usage & $O(\log n)$ & $O(1)$ & QuickSort uses recursive stack \\
    \bottomrule
\end{tabular}
\fonte{Theoretical and empirical algorithm analysis.}
\end{table}

\chapter{Hash Tables Analysis}

\section{Implementation}

The hash tables were implemented using open addressing with double hashing for collision resolution. This approach provides better distribution of elements compared to linear probing and helps maintain low collision rates.

\section{Results}

The results from the hash table experiments are available in the \texttt{output/} folder. The analysis includes:

\begin{itemize}
    \item Performance of record insertion into the hash table
    \item Efficiency of author search
    \item Analysis of collisions and rehashing
\end{itemize}

% Fixed table for Hash Table results
\begin{table}[H]
\centering
\caption{Hash Table performance for different sizes}
\label{tab:hashtable-performance}
\begin{tabular}{c c c c c}
    \toprule
    \textbf{Records} & \textbf{Insertion Time (ms)} & \textbf{Collisions} & \textbf{Load Factor} & \textbf{Search Time (ms)} \\
    \midrule
    1,000 & -- & -- & -- & -- \\
    5,000 & -- & -- & -- & -- \\
    10,000 & -- & -- & -- & -- \\
    50,000 & -- & -- & -- & -- \\
    100,000 & -- & -- & -- & -- \\
    \bottomrule
\end{tabular}
\fonte{Results from conducted experiments.}
\end{table}

\section{Most Frequent Authors Analysis}

The results from identifying the most frequent authors are in \texttt{output/saidaPart2.txt}. Table \ref{tab:most-frequent-authors} presents the authors with the highest number of works in the dataset.

% Fixed table for most frequent authors
\begin{table}[H]
\centering
\caption{Top 10 most frequent authors in the dataset}
\label{tab:most-frequent-authors}
\begin{tabular}{c l c}
    \toprule
    \textbf{Rank} & \textbf{Author Name} & \textbf{Number of Works} \\
    \midrule
    1 & -- & -- \\
    2 & -- & -- \\
    3 & -- & -- \\
    4 & -- & -- \\
    5 & -- & -- \\
    6 & -- & -- \\
    7 & -- & -- \\
    8 & -- & -- \\
    9 & -- & -- \\
    10 & -- & -- \\
    \bottomrule
\end{tabular}
\fonte{Analysis of Book Depository dataset using hash table.}
\end{table}

\chapter{Balanced Data Structures Analysis}

\section{Red-Black Tree}

The results from the Red-Black tree experiments are in \texttt{output/saidaInsercao.txt} and \texttt{output/saidaBusca.txt}. Table \ref{tab:redblack-results} presents performance metrics for insertion and search operations.

% Fixed table for Red-Black Tree results
\begin{table}[H]
\centering
\caption{Red-Black Tree performance}
\label{tab:redblack-results}
\begin{tabular}{c c c c c}
    \toprule
    \textbf{Operations} & \textbf{Insertion Time (ms)} & \textbf{Search Time (ms)} & \textbf{Average Height} & \textbf{Rotations} \\
    \midrule
    1,000 & -- & -- & -- & -- \\
    5,000 & -- & -- & -- & -- \\
    10,000 & -- & -- & -- & -- \\
    50,000 & -- & -- & -- & -- \\
    100,000 & -- & -- & -- & -- \\
    \bottomrule
\end{tabular}
\fonte{Results from conducted experiments.}
\end{table}

\section{B+ Tree (d=2)}

The results from the B+ tree experiments with degree 2 are in \texttt{output/saidaInsercao.txt} and \texttt{output/saidaBusca.txt}. Table \ref{tab:bplus-d2-results} presents the performance metrics.

% Fixed table for B+ Tree (d=2) results
\begin{table}[H]
\centering
\caption{B+ Tree (d=2) performance}
\label{tab:bplus-d2-results}
\begin{tabular}{c c c c c}
    \toprule
    \textbf{Operations} & \textbf{Insertion Time (ms)} & \textbf{Search Time (ms)} & \textbf{Average Level} & \textbf{Leaf Nodes} \\
    \midrule
    1,000 & -- & -- & -- & -- \\
    5,000 & -- & -- & -- & -- \\
    10,000 & -- & -- & -- & -- \\
    50,000 & -- & -- & -- & -- \\
    100,000 & -- & -- & -- & -- \\
    \bottomrule
\end{tabular}
\fonte{Results from conducted experiments.}
\end{table}

\section{B+ Tree (d=20)}

The results from the B+ tree experiments with degree 20 are in \texttt{output/saidaInsercao.txt} and \texttt{output/saidaBusca.txt}. Table \ref{tab:bplus-d20-results} presents the performance metrics.

% Fixed table for B+ Tree (d=20) results
\begin{table}[H]
\centering
\caption{B+ Tree (d=20) performance}
\label{tab:bplus-d20-results}
\begin{tabular}{c c c c c}
    \toprule
    \textbf{Operations} & \textbf{Insertion Time (ms)} & \textbf{Search Time (ms)} & \textbf{Average Level} & \textbf{Leaf Nodes} \\
    \midrule
    1,000 & -- & -- & -- & -- \\
    5,000 & -- & -- & -- & -- \\
    10,000 & -- & -- & -- & -- \\
    50,000 & -- & -- & -- & -- \\
    100,000 & -- & -- & -- & -- \\
    \bottomrule
\end{tabular}
\fonte{Results from conducted experiments.}
\end{table}

\section{Comparative Analysis}

A complete comparative analysis of the results is available in the output files. Table \ref{tab:trees-comparison} presents a comparative summary between different tree structures.

% Fixed table for tree comparison
\begin{table}[H]
\centering
\caption{Comparative analysis: Red-Black Tree vs B+ Trees}
\label{tab:trees-comparison}
\begin{tabular}{l c c c}
    \toprule
    \textbf{Metric} & \textbf{Red-Black} & \textbf{B+ (d=2)} & \textbf{B+ (d=20)} \\
    \midrule
    Insertion Complexity & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\
    Search Complexity & $O(\log n)$ & $O(\log n)$ & $O(\log n)$ \\
    Space Complexity & $O(n)$ & $O(n)$ & $O(n)$ \\
    Maximum Height & $\leq 2\log(n+1)$ & $\leq \log_d(n)$ & $\leq \log_d(n)$ \\
    Optimization & Main memory & Disk & Disk (higher degree) \\
    \bottomrule
\end{tabular}
\fonte{Theoretical and empirical structure analysis.}
\end{table}

\chapter{Results and Discussion}

\section{Results Summary}

This section presents a summary of the results obtained from the conducted experiments. The complete data is organized in the \texttt{output/} folder and was analyzed for each type of structure and algorithm.

\section{Data Interpretation}

The data interpretation considered:

\begin{itemize}
    \item Theoretical complexity vs. empirical performance
    \item Impact of data size on metrics
    \item Comparison between different structures and algorithms
\end{itemize}

\section{Experiment Limitations}

The limitations identified in the experiments include:

\begin{itemize}
    \item Results depend on the execution environment (JVM)
    \item Input sizes limited to values in the \texttt{input/entrada.txt} file
    \item Time metrics may vary between executions
\end{itemize}

\chapter{Conclusions and Future Work}

\section{Conclusions}

This work presented a comprehensive analysis of different data structures and algorithms. The experimental results demonstrate the characteristics and performance trade-offs of each implementation, providing valuable insights for selecting appropriate data structures based on application requirements.

The analysis of sorting algorithms revealed the importance of considering both average and worst-case performance when choosing an algorithm. Hash tables proved to be highly efficient for frequency analysis tasks, while balanced trees showed consistent logarithmic performance for large datasets.

\section{Future Work}

Possible extensions of this work include:

\begin{itemize}
    \item Implementation of other balanced data structures (AVL trees, Splay trees)
    \item Space complexity analysis
    \item Additional algorithm optimizations
    \item Analysis on larger datasets
    \item Parallel processing implementations
    \item Cache performance analysis
    \item Integration with continuous integration (CI) systems for automated testing
    \item Performance regression testing framework
\end{itemize}

% Bibliography
\singlespacing
\bibliographystyle{abntex2-alf}
\bibliography{referencias}

\end{document}
